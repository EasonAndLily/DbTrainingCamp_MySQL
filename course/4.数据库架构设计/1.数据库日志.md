# 数据库日志

![mysql-log-file](https://tva1.sinaimg.cn/large/008i3skNgy1grybnakxzaj30p00dw0th.jpg)

MySQL的二进制日志是构建高可用架构的基础，是实现数据库恢复或主从复制的必要手段，所以了解MySQL的二进制日志备份策略是深入学习MySQL必走之路，今天我们就来深入学习它！

MySQL日志可以分为很多种，前面我们说过的`Redo Log`和`Undo Log`日志属于MySQL存储引擎层的日志，而我们今天学习的`二进制日志`、`慢查日志`、`通用日志`等属于MySQL服务层日志，与具体的存储引擎无关，属于MySQL自身的日志，我们今天着重来了解这种日志。

MySQL的二进制日志（binary log）是一个二进制文件，主要用于记录修改数据或有可能引起数据变更的MySQL语句。二进制日志（binary log）中记录了对MySQL数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其它额外信息，但是它不记录SELECT、SHOW等那些不修改数据的SQL语句。

通常来看，MySQL二进制日志格式通常分为两种：

## 基于段的日志格式
基于段的格式：binlog_format=STATEMENT, 这种格式记录的是MySQL执行修改过数据的SQL语句。

这种日志格式具有以下优点：
* 由于记录是SQL语句，所以日志积累量相对较少，能够磁盘及网络I/O.
* 这种日志格式对于数据库备份来说历史悠久，成熟度较高，bug较少，是比较稳定的方案。

但是，这种日志的缺点也比较明显：
* 必须要记录上下文信息才能保证语句在从服务器上执行结果和在主服务器上面相同。
* 一些特定的函数如UUID(),user()等这样非确定性的函数还是无法复制，所有有可能造成主备服务器数据不一致。

## 基于行的日志格式
MySQL5.7之后，日志格式默认为基于行的：`binlog_format=row`, 目前MySQL官方主推这种日志格式，这种日志格式可以避免MySQL复制过程中出现的主从不一致问题，这种日志格式记录的是修改数据的每一行产生的结果，比如同一SQL语句修改了1000条数据，基于段的日志格式只会记录这条SQL语句，而基于行的日志会有1000条记录分别记录每一行的数据修改。

优点：
* 使得MySQL主从复制更加安全和主从数据的一致性。
* 对每一行数据的修改比基于段的复制高效，降低主从复制的延迟。
* 由于误操作修改了数据库中的数据，同时有没有备份可以恢复时，我们就可以通过分析二进制日志，对日志中记录的数据修改操作做反向处理来达到恢复数据的目的。

缺点：
* 由于记录了每一行的数据修改，所以记录了大量的数据，磁盘占用较高。目前这个问题可以通过配置`binlog_row_image=[FULL|MINIMAL|NOBLOB]`来设置，分别表示全量，按照列来记录，不要记录TEXT和BLOB的数据。

## 混合日志格式
除了上面所说的两种日志格式之外，还有存在一种混合的方式：`binlog_format=MIXED`, 这是一种折中的选择，这种日志格式的特点是根据SQL语句由系统决定在基于段和行的日志格式中进行选择，对于大部分日志将使用段的日志记录，对于有些段的日志无法记录的，将使用行来记录。另外，数据量的大小由所执行的SQL语句决定。

** 建议：我们一般推荐基于row和mixed的格式来记录日志，如果主从机器在同一机房的同一网段，我们强烈推荐基于row的记录方式，同时尽量使用`MINIMAL`这种方式。**


## 一些常用命令：
* 显示日志格式的配置：`show variables like 'binlog_format';`
* 配置日志格式：`set session binlog_format=statement;`
* 刷新log：`flush logs`
* 显示log文件名称：`show binary logs;`
* 查看基于段日志文件内容:`mysqlbinlog [log_name];`
* 查看基于行的日志文件内容: `mysqlbinlog -vv [log_name];`
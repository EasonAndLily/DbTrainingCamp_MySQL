# 逻辑设计

本节主要需要大家掌握逻辑设计的概念，E-R图的绘制，以及数据库设计的常用范式。



## 概述

从前面的数据库设计概述中，我们了解到逻辑设计位于需求分析之后，主要将需求设计的产物转化成逻辑模型，并将逻辑模型用E-R图呈现出来的过程。该过程不依赖于具体的数据库实体。所以，逻辑设计主要有两件事情：



### 1. 需求设计转成逻辑模型

该过程是十分关键的一环，在需求分析之后，将需求分析的结果按照逻辑模型进行归类。我们先来了解一下逻辑模型中的专有名词：

#### 逻辑模型中的专有名词

* **实体： **  *在系统中存在的实实在在的个体。通常对应一张实体表。* 比如学生考试系统中的老师，学生，课程等就是实体。
* **关系：** *实体与实体时间的联系。通常一个关系对应一张表* 。 比如学生与课程之间就是多对多的关系。
* **属性：** *实体的属性，通常在表中表示一列，即列名称称为属性名。* 比如学生有姓名，年龄等属性
* **域：** *属性的取值范围。* 比如学生的性别不是男就是女，这就是取值范围。
* **候选码：** *实体中某个属性，可以用来确定唯一的实体。* 比如学生实体的学生编号就是候选码。
* **主码：** *多个候选码中选择一个为主码，在表中表示为主键。* 比如学生编号可以作为主码，即主键。

### 2. 用E-R图呈现逻辑模型

E-R就是将逻辑模型用特殊的形状呈现出来：

* **实体：** 用**矩形**来表示，矩形内写实体集的名字。
* **关系：** 用**菱形**来表示，菱形内部写实体之间的关系。
* **属性：** 用**椭圆**来表示，椭圆里面写属性的名称。
* **联系：** 实体与属性之间用线段链接。
* **主码：** 在属性名称下面用**波浪线**标注。

### 举个例子：

学生考试系统中，有两个实体极其属性：

* 学生：学号，姓名，年龄，性别，身份证
* 科目：科目编号，科目名称，授课教师

他们之间的关系是：学生可以参加多门科目的考试，每个科目可以有多个学生参加，所以学生和考试科目之间通过考试分数来连接起来。

**用E-R图表示如下：**

![](http://ww1.sinaimg.cn/large/af4e9f79gy1g04yaqfzgdj21dg0p4gr5.jpg)

### 推荐制作E-R图软件

1. **[StarUML](http://staruml.io/download)**
2. 在线绘图工具：[Draw](https://www.draw.io/)
3. PPT也可以做简单的绘制



## 数据库设计基本范式(Normal Form)

数据库的设计范式是数据库设计所需要满足的规范，数据库的规范化是优化表的结构和优化把数据组织到表中的方式，这样使数据更明确，更简洁。是“广大劳动人民”在实践经验中的总结。

通常糟糕的数据库设计会让数据库表产生插入/删除/更新异常，给数据库维护带来极大的麻烦。

总体来看，数据库范式有：1NF，2NF，3NF，BCNF，4NF，5NF，DKNF，6NF。通常所用到的只是前三个范式，即：第一范式(1NF)，第二范式(2NF)，第三范式(3NF)。

本文主要了解三大范式。

### 第一范式(1NF)

**定义： 数据库表中的字段都是单一属性的，不可再分的。**

简单的说，每一个属性都是原子项，不可分割。这个单一属性是由基本的数据类型所构成的，如整数、浮点数、字符串等。换句话说：**第一范式要求数据库中的表都是二维表！**

**请看下面的例子：**

![](http://ww1.sinaimg.cn/large/af4e9f79ly1g05rx94m44j20xe04uq41.jpg)

从上面的学生表可以看出，学生的联系方式分为两列：家庭电话和个人电话。这是不符合第一范式的要求。如果在实际中遇到这种可以拆分的列，最好是新增一张表，然后在原表中建立和新增表的关系既可。上面的表可以拆分成两个表：学生表和联系方式表。

| 编号 | 姓名 | 年龄 | 性别 | 联系方式 |
| :--: | :--: | :--: | :--: | :------: |
|  1   | 张三 |  18  |  男  |   1001   |
|  2   | 李四 |  20  |  女  |   1002   |

| 编号 |  家庭电话   |  个人电话   |
| :--: | :---------: | :---------: |
| 1001 | 13888888888 | 15388888888 |
| 1002 | 13456789432 | 18767876789 |



### 第二范式(2NF)

**定义：数据库中的表中不存在非关键字段对任一候选关键字段的部分函数依赖。**

第二范式(2NF)要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。

**请看下面的例子：**

| 科目 | 授课教师 | 学生 | 分数 |
| :--: | :------: | :--: | :--: |
| 语文 |  李老师  | 张三 |  90  |
| 数学 |  张老师  | 李四 |  80  |

从上面的学生成绩表可以看出，授课教师和学生都依赖于考试科目，而分数却依赖于考试科目和学生的组合。所以，分数对考试科目存在着部分依赖。不符合第二范式。通常我们需要为表增加一列，即主键列，让所有属性列都完全依赖于主键列。如下：

| 成绩编号 | 科目 | 授课教师 | 学生 | 分数 |
| :------: | :--: | :------: | :--: | :--: |
|    1     | 语文 |  李老师  | 张三 |  90  |
|    2     | 数学 |  张老师  | 李四 |  80  |



### 第三范式(3NF)

**定义：如果数据表中不存在非关键字对候选关键字段的传递函数依赖，则符合第三范式。**

第三范式是在第一和第二范式的基础之上提出的，是第二范式的扩展，换句话说，第三范式必须完全依赖于关键字段，不能存在于传递函数依赖。

**举个例子：**

比如第二范式里面的这张学生成绩表：
| 成绩编号 | 科目 | 授课教师 | 学生 | 分数 |
| :------: | :--: | :------: | :--: | :--: |
|    1     | 语文 |  李老师  | 张三 |  90  |
|    2     | 数学 |  张老师  | 李四 |  80  |

仔细分析会发现，科目，学生和分数都完全依赖于成绩编号，但是授课教师却依赖于科目，即存在传递依赖：授课教师>科目>成绩编号。对于这种情况，通常将依赖传递的字段新建一张表。如下：

| 编号 | 科目编号 | 学生 | 分数 |
| ---- | -------- | ---- | ---- |
| 1    | 1001     | 张三 | 90   |
| 2    | 1002     | 李四 | 80   |

| 科目编号 | 科目名称 | 授课老师 |
| -------- | -------- | -------- |
| 1001     | 语文     | 李老师   |
| 1002     | 数学     | 张老师   |



## 家庭作业

